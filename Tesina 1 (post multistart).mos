model Progetto
  options noimplicit
  uses "mmxprs", "mmsystem"
  ! forward procedure Print_Status
  forward procedure modello_matematico
  forward procedure BPP_GP_output_MM
  forward procedure BPPGP_euristico
  forward procedure BPPGP_Multistart
  forward procedure BPPGP_Euristico_con_pval
  forward procedure BPPGP_LS
  forward procedure BPPGP_GRASP
  declarations

    n: integer !numero di item, integer
    m: integer !numero di bin
    l: integer !numero di archi
    c : integer ! capacità dei bin

    ! inputfile = "BPP_progettoMOLP.dat" !nome del file
    inputfile = "n_20_pval.dat"

  end-declarations

  initialisations from inputfile
    n
    m
    l
    c
  end-initialisations

  declarations
    items = 1..n !range degli items
    bins = 1..m !range dei bins
    archi = 1..l ! range degli archi
    pesi : array(items) of integer ! array dei pesi
    z : linctr !funzione obiettivo
    !prec : array(items, items) of integer !matrice delle precedenze
    partenza : array(archi) of integer !item da cui parte l'arco della precedenza
    arrivo : array(archi) of integer !item a cui arriva l'arco della precedenza
    pval : array(archi) of integer !valore sull'arco della precedenza
    t1,t2 : real
    eps= 0.0001
    max_iter : integer

    y: array(bins) of mpvar ! bins aperti
    x: array(bins, items) of mpvar !a che bin appartiene ogni item
    xeur: array(items) of integer
    zeur : integer
    xbest: array(items, bins) of integer
    zbest: integer
    ndisp: integer
  end-declarations

  initialisations from inputfile
    arrivo
    partenza
    pesi
    pval
  end-initialisations

  !!!!!!MAIN!!!!!!!
  max_iter := 500


  ! write(arrivo)
  ! BPPGP_euristico
  ! BPPGP_Multistart
  ! BPPGP_Euristico_con_pval
  ! BPPGP_LS
  BPPGP_GRASP
  modello_matematico
  t1 := gettime
  minimize(z)
  t2 := gettime
  
  ! Print_Status
  BPP_GP_output_MM
  !!!!!!!!!END MAIN !!!!!!!!!!

  procedure BPPGP_GRASP
    declarations
      disp: array(items) of integer
      sel: array(items) of integer
      getdisp : boolean
      controllati: array(items) of integer
      check_result: boolean
      indice : integer
      fine : boolean
      cap : integer
      pvalmax : integer
      swap : integer
      clist : array(items) of integer !Candidate  List del GRASP
    end-declarations
    zeur := 1
    fine := false
    ndisp := 0
    forall(i in items) sel(i) := 0
    forall(i in items) disp(i) := 1
    forall(i in archi) disp(arrivo(i)) := 0
    forall(i in items) xeur(i):= 0
    cap := c
    while (not fine) do
      fine := true
      ndisp := 0
      getdisp := false
      forall (o in items) do
        if (disp(o) = 1 and sel(o) <> 1) then
          getdisp := true
          ndisp += 1
        end-if
      end-do
      while(not getdisp) do
        forall (i in items) controllati(i) := 0
        zeur += 1
        cap := c
        writeln("Costretto ad aprire ", zeur, " -> ")
        forall(i in archi) do
          if (sel(arrivo(i)) <> 1 and controllati(arrivo(i)) <> 1) then
            check_result := true
            forall(h in archi, j in bins) do
              if (arrivo(h) = arrivo(i) and (sel(partenza(h)) <> 1 or (xeur(partenza(h)) = j and zeur - pval(h) - j < 0))) then
                check_result := false
                break
              end-if
            end-do
            if (check_result) then
              disp (arrivo(i)) := 1
              getdisp := true
              ndisp += 1
            end-if
            controllati(arrivo(i)) := 1
          end-if
        end-do
      end-do
      forall (i in items) clist(i) := 0
      pvalmax := 0
      !Si vuole individuare il valore massimo sugli archi di precedenza uscenti dagli item disponibili
      forall (i in items, j in archi) do
        ! aggiorniamo una variabile pvalmax che trovi il massimo dei pval
        if(pval(j) > pvalmax and disp(i) = 1 and sel(i) = 0 and partenza(j) = i) then
          ! 1) Il valore di pval dell'arco j deve essere maggiore rispetto a quello di pvalmax
          ! 2) L'item i deve essere disponibile
          ! 3) L'item i non deve essere selezionato
          ! 4) L'item i deve essere la partenza dell'arco j
          pvalmax := pval(i)
        end-if
      end-do
      ! Se (pvalmax - 2) è maggiore di 0 inseriamo nella candidate list tutti gli item (disponibili) da cui parte un arco con valore di
      ! precedenza maggiore a (pvalmax - 2)
      if ((pvalmax - 2) >= 0) then
        forall (i in items, j in archi) do
          if (pval(j) >= (pvalmax - 2) and disp(i) = 1 and sel(i) = 0 and partenza(j) = i) then
            clist(i) := 1
          end-if
        end-do
      else
      ! Se (pmax - 2) < 0 mettiamo tutti i disponibili nella candidate list
        forall(i in items) do
          if(disp(i) = 1) then
            clist(i) := 1
          end-if
        end-do
      end-if
      ! selezioniamo un item casuale presente nella candidate list
      while(true) do
        indice := ceil(random*n)
        if(clist(indice) = 1) then
          break
        end-if
      end-do
      write("Seleziono ", indice, " -> ")
      ! La restante parte del codice equivale all'euristico costruttivo RANDOM
      if (pesi(indice) <= cap) then 
        cap -= pesi(indice)
      else
        zeur := zeur + 1
        cap := c - pesi(indice)
      end-if
      writeln("Assegno a bin: ", zeur, " (capacità residua: ", cap,")")
      ndisp -= 1
      sel(indice) := 1
      disp(indice) := 0
      xeur(indice) := zeur
      forall (i in items) controllati(i) := 0
      forall(i in archi) do
        if (sel(arrivo(i)) <> 1 and controllati(arrivo(i)) <> 1) then
          check_result := true
          forall(h in archi, j in bins) do
            if (arrivo(h) = arrivo(i) and (sel(partenza(h)) <> 1 or (xeur(partenza(h)) = j and zeur - pval(h) - j < 0))) then
              check_result := false
              break
            end-if
          end-do
          if (check_result) then
            disp (arrivo(i)) := 1
          end-if
          controllati(arrivo(i)) := 1 
        end-if
      end-do
      forall (i in items)
        if (sel(i) = 0) then 
          fine := false
          break
        end-if
    end-do
    writeln("SOLUZIONE EURISTICO COSTRUTTIVO, con criterio GRASP")
    writeln("\tZEUR [GRASP] = ",zeur)
    write("\t")
    forall(i in items) do
        write("(", i,", ",xeur(i),"); ")
    end-do
    writeln
  end-procedure

  procedure BPPGP_LS
    declarations
      disp: array(items) of integer
      sel: array(items) of integer
      getdisp : boolean
      controllati: array(items) of integer
      check_result: boolean
      indice : integer
      fine : boolean
      cap : integer
      pvalmax : integer
      pesomax : integer
      ndisp : integer                                       ! Numero di item a disponibili per la selezione
      swap : integer                                        ! Indice dell'item con cui sostituire il selezionato
    end-declarations
    zeur := 1
    fine := false
    ndisp := 0
    forall(i in items) sel(i) := 0
    forall(i in items) disp(i) := 1
    forall(i in archi) disp(arrivo(i)) := 0
    forall(i in items) xeur(i):= 0
    cap := c
    while (not fine) do
      fine := true
      ndisp := 0
      getdisp := false
      forall (o in items) do
        if (disp(o) = 1 and sel(o) <> 1) then
          getdisp := true
          ndisp +=1                                         !Contiamo il numero di items disponibili
        end-if
      end-do
      while(not getdisp) do
        forall (i in items) controllati(i) := 0
        zeur += 1
        cap := c
        writeln("Costretto ad aprire ", zeur, " -> ")
        forall(i in archi) do
          if (sel(arrivo(i)) <> 1 and controllati(arrivo(i)) <> 1) then
            check_result := true
            forall(h in archi, j in bins) do
              if (arrivo(h) = arrivo(i) and (sel(partenza(h)) <> 1 or (xeur(partenza(h)) = j and zeur - pval(h) - j < 0))) then
                check_result := false
                break
              end-if
            end-do
            if (check_result) then
              disp (arrivo(i)) := 1
              getdisp := true
              ndisp += 1
            end-if
            controllati(arrivo(i)) := 1
          end-if
        end-do
      end-do
      indice := 0
      pvalmax := -1
      forall (i in items, j in archi ) do
        if (disp(i) = 1 and sel(i) = 0 and partenza(j) = i and pval(j) > pvalmax) then
          ! write ("indice = " ,i, ", pval = ", pval(j), " -> ")
          indice := i
          pvalmax := pval(j)
        end-if
      end-do
      if (indice <> 0) then
        write ("Seleziono ",indice," -> ")
      end-if
      if (indice = 0) then
        pesomax := 0
        forall (i in items) do
          if(disp(i) = 1 and sel(i) = 0 and pesi(i) > pesomax and pesi(i) < cap) then
            indice := i
            pesomax := pesi(i)
          end-if
        end-do
        if (indice <> 0) then
          write( "CR ", indice," -> ")
        end-if
      end-if
      if(indice = 0) then
        pesomax := 0
        forall (i in items) do
          if(disp(i) = 1 and sel(i) = 0 and pesi(i) > pesomax) then
            indice := i
            pesomax := pesi(i)
          end-if
        end-do
        write( "Peso -> ",indice," -> ")
      end-if      
      ! Lo SWAP avviene dopo la selezione "con criterio" dell'item
      if(random < 0.5 and ndisp > 1) then                                 ! Lo SWAP avviene con una certa probabilità e solo se esistono altri item disponibili
        while (true) do
          swap := ceil(random * n)
          ! Il nuovo item viene selezionato random tra i disponibili e deve essere diverso da quello che era stato scelto
          if(disp(swap) = 1 and sel(swap) = 0 and swap <> indice) then
            indice := swap                                                ! Indice viene aggiornato
            write ("SWAP = ",indice , " -> ")
            break
          end-if
        end-do
      end-if
      ! La restante parte del codice equivale all'euristico costruttivo RANDOM
      if (pesi(indice) <= cap) then 
        cap -= pesi(indice)
      else
        zeur := zeur + 1
        cap := c - pesi(indice)
      end-if
      writeln("Assegno a bin: ", zeur, " (capacità residua: ", cap,")")
      ndisp -= 1
      sel(indice) := 1
      disp(indice) := 0
      xeur(indice) := zeur
      forall (i in items) controllati(i) := 0
      forall(i in archi) do
        if (sel(arrivo(i)) <> 1 and controllati(arrivo(i)) <> 1) then
          check_result := true
          forall(h in archi, j in bins) do
            if (arrivo(h) = arrivo(i) and (sel(partenza(h)) <> 1 or (xeur(partenza(h)) = j and zeur - pval(h) - j < 0))) then
              check_result := false
              break
            end-if
          end-do
          if (check_result) then
            disp (arrivo(i)) := 1
          end-if
          controllati(arrivo(i)) := 1 
        end-if
      end-do
      forall (i in items)
        if (sel(i) = 0) then 
          fine := false
          break
        end-if
    end-do

    write("SOLUZIONE EURISTICO COSTRUTTIVO, con LOCAL SEARCH")
    writeln("\tZEUR = ",zeur)
    ! forall(i, j in xeur)
    !   if(xeur(i, j) > eps) then
    !     write("x(", i,", ", j, " = 1")
    !   end-if


  end-procedure

  procedure BPPGP_Euristico_con_pval
    declarations
      disp: array(items) of integer
      sel: array(items) of integer
      getdisp : boolean
      controllati: array(items) of integer
      check_result: boolean 
      indice : integer
      fine : boolean
      cap : integer
      pvalmax : integer                                   ! Variabile per il confronto dei pval tra gli archi di precedenza
      pesomax : integer                                   ! Variabile per il confronto dei pesi tra gli item
    end-declarations
    zeur := 1
    fine := false
    forall(i in items) sel(i) := 0
    forall(i in items) disp(i) := 1
    forall(i in archi) disp(arrivo(i)) := 0
    forall(i in items) xeur(i):= 0
    cap := c
    while (not fine) do
      fine := true
      getdisp := false
      forall (o in items) do
        if (disp(o) = 1) then
          write(o, " è disponibile -> ")
          getdisp := true
          break
        end-if
      end-do
      while(not getdisp) do
        forall (i in items) controllati(i) := 0
        zeur += 1
        cap := c
        writeln("Costretto ad aprire ", zeur, " -> ")
        forall(i in archi) do
          if (sel(arrivo(i)) <> 1 and controllati(arrivo(i)) <> 1) then
            check_result := true
            forall(h in archi, j in bins) do
              if (arrivo(h) = arrivo(i) and (sel(partenza(h)) <> 1 or (xeur(partenza(h)) = j and zeur - pval(h) - j < 0))) then
                check_result := false
                break
              end-if
            end-do
            if (check_result) then
              disp (arrivo(i)) := 1
              getdisp := true
            end-if
            controllati(arrivo(i)) := 1
          end-if
        end-do
      end-do
      ! Si seleziona un item secondo una specifiche serie di criteri
      indice := 0
      pvalmax := -1                                       ! Viene impostato a -1 perchè esistono anche precedenze con valore 0
      forall (i in items, j in archi ) do
        ! Attraverso questi confronti si seleziona l'item (disponibile) "partenza" associato all'arco con pval maggiore 
        if (disp(i) = 1 and sel(i) = 0 and partenza(j) = i and pval(j) > pvalmax) then
          ! 1) L'item deve essere disponibile
          ! 2) L'item non deve essere già selezionato
          ! 3) L'item deve essere la "partenza" di un arco di precedenza
          ! 4) Il pval associato all'arco partente dall'item deve essere maggiore a pvalmax 
          write ("indice = " ,i, ", pval = ", pval(j), " -> ")
          indice := i
          pvalmax := pval(j)                              ! Si aggiorna pvalmax quando viene superato da un nuovo item
        end-if
      end-do
      ! write(" Scelgo ", indice," -> ")
      ! Esistono situazioni in cui abbiamo item disponibili ma nessuno può essere scelto (ad esempio se nessuno è una partenza)
      ! In questi casi è previsto un secondo criterio: l'item il cui peso satura al massimo la capacità del bin corrente.
      if (indice = 0) then                                ! Indice vale 0 solo se non è stato selezionato nessun item
        write( "Valutiamo la capacità residua -> ")
        pesomax := 0
        forall (i in items) do
          ! Attraverso il confronto selezioniamo l'item che saturi al meglio il bin corrente
          if(disp(i) = 1 and sel(i) = 0 and pesi(i) > pesomax and pesi(i) < cap) then
            ! 1) L'item deve essere disponibile
            ! 2) L'item non deve essere già selezionato
            ! 3) L'item deve pesare più di pesomax
            ! 4) Il peso dell'item non deve eccedere la capacità del bin 
            indice := i
            pesomax := pesi(i)
          end-if
        end-do
      end-if
      ! Se ancora una volta nessun item soddisfa le condizioni si passa a scegliere semplicemente quello dal peso maggiore
      if(indice = 0) then
        write( "Valutiamo il peso -> ")
        pesomax := 0
        forall (i in items) do
          ! Attraverso il confronto selezioniamo l'item con il peso maggiore
          if(disp(i) = 1 and sel(i) = 0 and pesi(i) > pesomax) then
            ! 1) L'item deve essere disponibile
            ! 2) L'item non deve essere già selezionato
            ! 3) L'item deve pesare più di pesomax
            indice := i
            pesomax := pesi(i)
          end-if
        end-do
      end-if
      ! La restante parte del codice equivale all'euristico costruttivo RANDOM
      if (pesi(indice) <= cap) then 
        cap -= pesi(indice)
      else
        zeur := zeur + 1
        cap := c - pesi(indice)
      end-if
      writeln("Assegno a bin: ", zeur, " (capacità residua: ", cap,")")
      sel(indice) := 1
      disp(indice) := 0
      xeur(indice) := zeur
      forall (i in items) controllati(i) := 0
      forall(i in archi) do
        if (sel(arrivo(i)) <> 1 and controllati(arrivo(i)) <> 1) then
          check_result := true
          forall(h in archi, j in bins) do
            if (arrivo(h) = arrivo(i) and (sel(partenza(h)) <> 1 or (xeur(partenza(h)) = j and zeur - pval(h) - j < 0))) then
              check_result := false
              break
            end-if
          end-do
          if (check_result) then
            disp (arrivo(i)) := 1
          end-if
          controllati(arrivo(i)) := 1 
        end-if
      end-do
      forall (i in items)
        if (sel(i) = 0) then 
          fine := false
          break
        end-if
    end-do
    writeln("SOLUZIONE")
    writeln("euristico costruttivo con PVAL")
    writeln("\tzeur = ",zeur)
  end-procedure

  procedure BPPGP_Multistart
    zbest := zeur
    xbest := xeur
    forall (iterazione in 1..max_iter) do
      BPPGP_euristico
      if(zeur < zbest) then                     ! Se la soluzione dell'euristico è migliore dell'incumbet si aggiorna
        zbest := zeur
        xbest := xeur
      end-if
    end-do
    writeln ("SOLUZIONE MULTISTART")
    writeln ("\tzbest = ", zbest)
  end-procedure

  procedure BPPGP_euristico
    declarations
      disp: array(items) of integer             ! item che possono essere inseriti
      sel: array(items) of integer              ! item che sono già stati selezionati
      getdisp : boolean                         ! vero se esistono item che sono disponibili
      controllati: array(items) of integer      ! item in arrivo che sono stati controllati
      check_result: boolean                     ! indica se un item diventa disponibile o no
      indice : integer                          ! variabile che ricorda, durante l'iterazione, l'item che sto selezionando
      fine : boolean                            ! assume valore false quando ho selezionato tutti gli item
      cap : integer                             ! capacità residua del bin corrente
    end-declarations

    ! condizioni necessarie per iniziare l'euristico:
    fine := false
    forall(i in items) sel(i) := 0              ! Nessun item è inizialmente selezionato
    forall(i in items) disp(i) := 1             ! Tutti gli item sono disponibili ->
    forall(i in archi) disp(arrivo(i)) := 0     ! Pongo non disponibili gli item che sono arrivi di archi di precedenza
    forall(i in items) xeur(i):= 0              ! Assegno ad un ipotetico bin 0 tutti gli item nella soluzione euristica
    zeur := 1                                   ! Si parte per forza dal Bin 1
    cap := c                                    ! Il bin (1) aperto ha capacità corrente uguale alla capacità massima 
    ! Iniziamo il ciclo esterno, ad ogni iterazione un item viene assegnato ad un bin
    while (not fine) do
      fine := true                              ! Evitiamo che ci si blocchi nel while (se non sono assegnati tutti gli item rimettiamo True -> più avanti)
      getdisp := false
      forall (o in items) do
        if (disp(o) = 1) then                   ! Se ho almeno un item disponibile per la selezione getdisp -> true
          write(o, " è disponibile -> ")
          getdisp := true                       ! ->
          break                                 ! Appena trovo un match interrompo il ciclo
        end-if
      end-do
      ! Ciclo che viene percorso solamente in caso di non disponibilità (getdisp = False) -> apre un nuovo bin.
      ! Posso avere problemi di disponibilità causati dal valore sugli archi delle precedenze (pval):
      ! Pur avendo già selezionato tutti gli item necessari, non sono ancora trascorsi sufficienti bin.
      while(not getdisp) do
        forall (i in items) controllati(i) := 0 ! Controllare se (come si spera) qualche item diventa disponibile con l'apertura di un nuovo bin
        zeur += 1                               ! Apro il nuovo Bin
        cap := c                                ! Aggiorno la capacità
        writeln("Costretto ad aprire ", zeur, " -> ")
        forall(i in archi) do                   ! Si cicla sugli archi perchè è necessario controllare gli arrivi (degli archi di precedenza)
          if (sel(arrivo(i)) <> 1 and controllati(arrivo(i)) <> 1) then
            ! Devo controllare solamente gli item che non ho precedentemente selezionato / controllato 
            check_result := true                ! Inizialmente può essere inserito, se fallisce i controlli no
            forall(h in archi, j in bins) do
              ! Si cicla una seconda volta su archi perchè un item può essere arrivo di diversi archi, tutte le precedenze devono essere verificate
              ! perché l'arrivo diventi disponibile
              if (arrivo(h) = arrivo(i) and (sel(partenza(h)) <> 1 or (xeur(partenza(h)) = j and zeur - pval(h) - j < 0))) then
                ! 1) L'item "arrivo" nel ciclo interno deve coincidere con quello esterno (controllo tutti gli archi)
                ! 2) L'item "partenza" dell'arco è associato ad un bin j (quindi selezionato)
                ! 3) Devono essere passati sufficienti bin da soddisfare la precedenza
                check_result := false
                break
                ! Basta che una di queste condizione venga verificata e l'item non può diventare disponibile
              end-if
            end-do
            if (check_result) then              ! A seconda dell'esito del controllo inserisco tra i disponibili l'item "arrivo"
              disp (arrivo(i)) := 1
              getdisp := true
            end-if
            controllati(arrivo(i)) := 1         ! In ogni caso l'item "arrivo" è stato controllato 
          end-if
        end-do
      end-do
      ! Selezioniamo casualmente un item tra quelli disponibili
      while (true) do 
        indice := ceil(random * n)
        if(disp(indice) = 1 and sel(indice) = 0) then
          write ("Seleziono ", indice, " -> ")
          break
        end-if
      end-do
      ! Aggiornamento della capacità residua del bin
      if (pesi(indice) <= cap) then 
        cap -= pesi(indice)
      else                                      ! Se il peso dell'item selezionato eccede la capacità residua del bin corrente
        zeur := zeur + 1                        ! Apro un nuovo bin e aggiorno la capacità
        cap := c - pesi(indice)
      end-if
      writeln("Assegno a bin: ", zeur, " (capacità residua: ", cap,")")
      sel(indice) := 1                          ! L'item estratto e assegnato diventa "selezionato"
      disp(indice) := 0                         ! Togliamo la disponibilità dall'item selezionato (non deve essere ri-estratto)
      xeur(indice) := zeur                      ! All'indice dell'item (nell'array della soluzione euristica) è assegnato il numero del bin (coppia item-bin)
      ! Si effettua l'aggiornamento degli item disponibili.
      ! Abbiamo un item in più nell'array selezionati e potenzialmente abbiamo aperto un bin
      forall (i in items) controllati(i) := 0
      forall(i in archi) do
        if (sel(arrivo(i)) <> 1 and controllati(arrivo(i)) <> 1) then
          check_result := true
          forall(h in archi, j in bins) do
            if (arrivo(h) = arrivo(i) and (sel(partenza(h)) <> 1 or (xeur(partenza(h)) = j and zeur - pval(h) - j < 0))) then
              check_result := false
              break
            end-if
          end-do
          if (check_result) then
            disp (arrivo(i)) := 1
          end-if
          controllati(arrivo(i)) := 1 
        end-if
      end-do
      ! Se ho ancora degli item non selezionati, devo effettuare un altro ciclo
      forall (i in items)
        if (sel(i) = 0) then 
          fine := false
          break
        end-if
    end-do
    writeln("SOLUZIONE")
    writeln("euristico costruttivo RANDOM")
    writeln("\tzeur = ",zeur)
  end-procedure

  procedure modello_matematico
    z := sum(i in bins) y(i)                                                                  ! (1) funzione obiettivo
    forall (j in items) 
      sum(i in bins) x(i, j) = 1                                                              ! (2) ogni item assegnato esattamente ad un bin
    forall (i in bins) 
      sum (j in items) pesi(j) * x(i, j) <= c * y(i)                                          ! (3) vincolo di capacità per bin aperto
    forall (u in archi) 
      sum (i in bins) i * x (i, arrivo(u)) >= sum(i in bins) (i*x(i, partenza(u))) + pval(u)  ! (4) vincolo sulle relazioni di precedenze
    forall (i in 1..(m-1)) 
      y(i) >= y (i+1)                                                                         ! (5) bin aperti in ordine
    forall (i in bins) 
      y(i) is_binary                                                                          ! (6)
    forall (i in bins, j in items) 
      x(i, j) is_binary                                                                       ! (7)
  end-procedure

  ! procedure Print_Status
  !   !restituisce lo stato del problema e quindi la natura della soluzione ottenuta
  !   case getprobstat of
  !     XPRS_OPT: solution_status:="Optimum found"
  !     XPRS_UNF: solution_status:="Unfinished"
  !     XPRS_INF: solution_status:="Infeasible"
  !     XPRS_UNB: solution_status:="Unbounded"
  !     XPRS_OTH: solution_status:="Failed"
  !     else solution_status:="???"
  !   end-case
  !   writeln("Problem status: ", solution_status)
  ! end-procedure

  procedure BPP_GP_output_MM
    writeln("SOLUZIONE")
    writeln("\tz = ", getobjval)
    forall(i in bins) do
      if (getsol(y(i)) > eps) then
        writeln("\ty(", i, ") = ",getsol(y(i)))
        forall(j in items)
          if (getsol(x(i,j)) > eps) then
            writeln("\t\tx(",i,", ", j, ") = ", getsol(x(i,j)))
          end-if
      end-if
    end-do
  end-procedure

end-model
