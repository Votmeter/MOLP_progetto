model Progetto
  options noimplicit
  uses "mmxprs", "mmsystem"
  ! forward procedure Print_Status
  forward procedure modello_matematico
  forward procedure BPP_GP_output_MM
  forward procedure BPPGP_euristico
  forward procedure BPPGP_Multistart
  forward procedure BPPGP_Euristico_con_pval
  forward procedure BPPGP_LS
  forward procedure BPPGP_GRASP
  declarations

    n: integer !numero di item, integer
    m: integer !numero di bin
    l: integer !numero di archi
    c : integer ! capacità dei bin

    inputfile = "BPP_progettoMOLP.dat" !nome del file

  end-declarations

  initialisations from inputfile
    n
    m
    l
    c
  end-initialisations

  declarations
    items = 1..n !range degli items
    bins = 1..m !range dei bins
    archi = 1..l ! range degli archi
    pesi : array(items) of integer ! array dei pesi
    z : linctr !funzione obiettivo
    !prec : array(items, items) of integer !matrice delle precedenze
    partenza : array(archi) of integer !item da cui parte l'arco della precedenza
    arrivo : array(archi) of integer !item a cui arriva l'arco della precedenza
    pval : array(archi) of integer !valore sull'arco della precedenza
    t1,t2 : real
    eps= 0.0001
    max_iter : integer

    y: array(bins) of mpvar ! bins aperti
    x: array(bins, items) of mpvar !a che bin appartiene ogni item
    xeur: array(items) of integer
    zeur : integer
    xbest: array(items, bins) of integer
    zbest: integer
    ndisp: integer
  end-declarations

  initialisations from inputfile
    arrivo
    partenza
    pesi
    pval
  end-initialisations

  !!!!!!MAIN!!!!!!!
  max_iter := 500


  ! write(arrivo)
  ! BPPGP_euristico
  ! BPPGP_Multistart
  ! BPPGP_Euristico_con_pval
  ! BPPGP_LS
  BPPGP_GRASP
  modello_matematico
  t1 := gettime
  minimize(z)
  t2 := gettime
  ! Print_Status
  BPP_GP_output_MM
  !!!!!!!!!END MAIN !!!!!!!!!!

procedure BPPGP_GRASP
    declarations
      disp: array(items) of integer ! item che possono essere inseriti
      sel: array(items) of integer ! item che sono già stati selezionati
      getdisp : boolean ! ho items da prendere
      controllati: array(items) of integer ! item già controllati in arrivo
      check_result: boolean !esito del checking -> true può diventare disponibile
      indice : integer
      fine : boolean !Booleano per controllare la fine del ciclo
      cap : integer

      clist : array(items) of integer !Candidate  List del GRASP


      pmax : integer !massima valore sull'arco della precedenza
      cmax : integer
      swap : integer
    end-declarations

    zeur := 1 !Si parte per forza dal Bin 1
    fine := false
    forall(i in items) sel(i) := 0
    forall(i in items) disp(i) := 1

    forall(i in archi) disp(arrivo(i)) := 0
    forall(i in items) xeur(i):= 0

    cap := c
    while (not fine) do
      fine := true
      getdisp := false
      ndisp := 0
      forall (i in items) clist(i) := 0
      forall (o in items) do
        if (disp(o) = 1) then
          ! write(o, " è disponibile -> ")
          getdisp := true
          ndisp +=1 !Contiamo il numero di items disponibili
        end-if
      end-do

      while(not getdisp) do
        zeur += 1
        ! writeln("Costretto ad aprire ", zeur, " -> ")
        forall (i in items) controllati(i) := 0
        forall(i in archi) do
          if (sel(arrivo(i)) <> 1 and controllati(arrivo(i)) <> 1) then
              check_result := true
              forall(h in archi, j in bins) do
                if (items(arrivo(h)) = arrivo(i) and (sel(partenza(h)) <> 1 or (xeur(partenza(h)) = j and zeur - pval(h) - j < 0))) then
                    check_result := false
                    break
                end-if
              end-do
              if (check_result) then
                disp (arrivo(i)) := 1
                getdisp := true
                ndisp += 1
              end-if
              controllati(arrivo(i)) := 1
          end-if
        end-do
      end-do

      pmax := 0
      !Sugli archi uscenti dagli item disponibili vogliamo individuare il valore massimo
      forall (i in archi, j in items) do
        ! aggiorniamo una variabile pmax che trovi il massimo dei pval
        if(pval(i) > pmax and disp(j) = 1 and sel(j) = 0 and partenza(i) = j) then
          pmax := pval(i)
        end-if
      end-do
      ! Se pmax - 2 è maggiore di 0 inseriamo nella candidate list tutti gli item (disponibili) da cui parte un arco con valore di
      ! precedenza maggiore a pmax - 2
      if(pmax - 2 >= 0) then
        forall (j in items, i in archi) do
          if(pval(i) >= (pmax - 2) and disp(j) = 1 and sel(j) = 0 and partenza(i) = j) then
            clist(j) := 1
          end-if
        end-do
      else
      ! Se pmax - 2 < 0 mettiamo tutti i disponibili nella candidate list
        forall(i in items) do
          if(disp(i) = 1) then
            clist(i) := 1
          end-if
        end-do
      end-if
      ! selezioniamo un item casuale presente nella candidate list
      while(true) do
        indice := ceil(random*n)
        if(clist(indice) = 1) then
          break
        end-if
      end-do
      
      if (pesi(indice) > cap) then
        zeur := zeur + 1
        cap := c - pesi(indice)
      else cap -= pesi(indice)
      end-if
      ! writeln("zeur = ", zeur," cap = ", cap, " ->" )
      disp(indice) := 0 
      sel(indice) := 1
      xeur(indice) := zeur
      
      forall (i in items) controllati(i) := 0
      
      forall(i in archi) do
        if (sel(arrivo(i)) <> 1 and controllati(arrivo(i)) <> 1) then
            check_result := true
            forall(h in archi, j in bins) do
              if (items(arrivo(h)) = arrivo(i) and (sel(partenza(h)) <> 1 or (xeur(partenza(h)) = j and zeur - pval(h) - j < 0))) then
                  check_result := false
                  break
              end-if
            end-do
            if (check_result) then
              disp (arrivo(i)) := 1
            end-if
            controllati(arrivo(i)) := 1
        end-if
      end-do

      forall (i in items)
        if (sel(i) = 0) then fine := false
        end-if

    end-do
    writeln("SOLUZIONE EURISTICO COSTRUTTIVO, con criterio GRASP")
    writeln("\tZEUR [GRASP] = ",zeur)
    write("\t")
    forall(i in items) do
        write("(", i,", ",xeur(i),"); ")
    end-do
    writeln
  end-procedure


  procedure BPPGP_LS
    declarations
      disp: array(items) of integer ! item che possono essere inseriti
      sel: array(items) of integer ! item che sono già stati selezionati
      getdisp : boolean ! ho items da prendere
      controllati: array(items) of integer ! item già controllati in arrivo
      checking: integer !item in arrivo che sto controllando
      check_result: boolean !esito del checking -> true può diventare disponibile
      indice : integer
      fine : boolean !Booleano per controllare la fine del ciclo
      cap : integer

      pmax : integer !massima valore sull'arco della precedenza
      cmax : integer
      swap : integer
    end-declarations

    zeur := 1 !Si parte per forza dal Bin 1
    fine := false
    forall(i in items) sel(i) := 0
    forall(i in items) disp(i) := 1

    forall(i in archi) disp(arrivo(i)) := 0
    forall(i in items) xeur(i):= 0

    cap := c
    while (not fine) do
      fine := true
      getdisp := false
      ndisp := 0

      !Ciclo per controllare la disponibilità di item da selezionare
      forall (o in items) do
        if (disp(o) = 1) then
          write(o, " è disponibile -> ")
          getdisp := true
          ndisp +=1
        end-if
      end-do

      !Ciclo che viene percorso solamente in caso di non disponibilità: apre un nuovo bin se necessario
      while(not getdisp) do
        zeur += 1
        writeln("Costretto ad aprire ", zeur, " -> ")

        forall (i in items) controllati(i) := 0 !azzero gli item controllati
        forall(i in archi) do
          if (sel(arrivo(i)) <> 1) then
          !controllo solo gli item in arrivo che non ho già selezionati;va fatto prima del prossimo per poter azzerare sempre i controllati
            if (controllati(arrivo(i)) <> 1) then
              check_result := true !Inizialmente può essere inserito, se fallisce i controlli no
              checking := arrivo(i) !Sto controllanto l'item arrivo(i)

              !##### Ecco la ciccia: i controlli #####!
              forall(h in archi) do

                if (items(arrivo(h)) = checking) then
                  !quando nell'array arrivo trovo l'item che stiamo controllando ->
                  if (sel(partenza(h)) <> 1) then
                    ! Se la partenza non è stata selezionata -> il controllo fallisce
                    check_result := false
                    break
                  end-if
                  !Questo punto del codice viene raggiunto solamentese tutte gli item con precedenze sono stati già assegnati

                  forall(j in bins) do
                    !Facciamo ruotare la variabile j sui bin ->
                    if (xeur(partenza(h)) = j and zeur - pval(h) - j < 0) then
                      !Se ho assegnato l'item che sto controllando [partenza(h)] al bin numero [j],
                      !controllo che il numero del bin attuale [zeur] - il peso della precedenza [pval(h)] - il numero del bin dell'item con precedenza [j]
                      !sia maggiore o uguale a zero -> sia passato abbastanza tempo
                      !altrimenti il controllo fallisce
                      check_result := false
                      break

                    end-if
                  end-do
                  if(not check_result) then break
                  end-if
                end-if
              end-do

              if (check_result) then
              !Qui, se i controlli non sono falliti, aggiorniamo la disponibilità -> nel prossimo passaggio possiamo prendere quell'item che stava in arrivo
                disp (arrivo(i)) := 1
                getdisp := true
                ndisp +=1
              !Altrimenti consideriamo semplicemente controllato l'arrivo a questo item
              controllati(arrivo(i)) := 1
              end-if
            end-if
          end-if
        end-do

      end-do



      ! Qui  selezioniamo un indice
      indice := 0 !lo dichiariamo a 0
      pmax := -1
      forall (i in items, j in archi ) do
        if  (disp(i) = 1 and sel(i) = 0 and partenza(j) = i) then
          ! if (partenza(j) = i) then
            ! Qui aggiorniamo l'indice selezionato considerando il suo pval
            if (pval(j) > pmax) then
              write ("indice = " ,i, ", pval = ", pval(j), " -> ")
              indice := i
              pmax := pval(j)
            end-if
          ! end-if
        end-if
      end-do

      write(" Scelgo ", indice," -> ")
      if (indice = 0) then
        write( "indice = 0 ->")
        cmax := 0
        forall (i in items) do
          if(disp(i) = 1 and sel(i) = 0 and pesi(i) > cmax and pesi(i) < cap) then
            indice := i
          end-if
        end-do
      end-if

      if(indice = 0) then
          while (true) do

        ! while (true) do ! trova un indice disponibile casualmente
          indice := ceil(random * n)

          if(disp(indice) = 1 and sel(indice) = 0) then
            write ("Seleziono ", indice, " -> ")
            break
          end-if
        end-do
      end-if

      if(random < 0.5 and ndisp >1 )then
        while (true) do

        ! while (true) do ! trova un indice disponibile casualmente
          swap := ceil(random * n)

          if(disp(swap) = 1 and sel(swap) = 0 and swap <> indice) then
            write ("SWAP = ",swap , " -> ")
            indice := swap
            break
          end-if
        end-do
      end-if

      if (pesi(indice) > cap) then
        zeur := zeur + 1
        cap := c - pesi(indice)
      else cap -= pesi(indice)
      end-if

      writeln("zeur = ", zeur," cap = ", cap, " ->" )

      disp(indice) := 0 !togliamo la disponibilità di indice
      sel(indice) := 1

      xeur(indice) := zeur

      !!!!!!!!!!!!AGGIORNAMENTO SEL!!!!!!!!!!

      !!ciclo di controllo precedenze!!
      forall (i in items) controllati(i) := 0 !azzero gli item controllati

      forall(i in archi) do
        if (sel(arrivo(i)) <> 1) then
        !controllo solo gli item in arrivo che non ho già selezionati;va fatto prima del prossimo per poter azzerare sempre i controllati
          if (controllati(arrivo(i)) <> 1) then
            check_result := true !Inizialmente può essere inserito, se fallisce i controlli no
            checking := arrivo(i) !Sto controllanto l'item arrivo(i)
            ! writeln("checnking: ", checking)

            !##### Ecco la ciccia: i controlli #####!
            forall(h in archi) do

              if (items(arrivo(h)) = checking) then
                !quando nell'array arrivo trovo l'item che stiamo controllando ->
                if (sel(partenza(h)) <> 1) then
                  ! Se la partenza non è stata selezionata -> il controllo fallisce
                  check_result := false
                  break
                end-if
                !Questo punto del codice viene raggiunto solamentese tutte gli item con precedenze sono stati già assegnati

                forall(j in bins) do
                  !Facciamo ruotare la variabile j sui bin ->
                  if (xeur(partenza(h)) = j and zeur - pval(h) - j < 0) then
                    !Se ho assegnato l'item che sto controllando [partenza(h)] al bin numero [j],
                    !controllo che il numero del bin attuale [zeur] - il peso della precedenza [pval(h)] - il numero del bin dell'item con precedenza [j]
                    !sia maggiore o uguale a zero -> sia passato abbastanza tempo
                    !altrimenti il controllo fallisce
                    check_result := false
                    break

                  end-if
                end-do

                if(not check_result) then break
                end-if
              end-if
            end-do

            if (check_result) then
            !Qui, se i controlli non sono falliti, aggiorniamo la disponibilità -> nel prossimo passaggio possiamo prendere quell'item che stava in arrivo
              disp (arrivo(i)) := 1
              ! writeln("diventa disponibile ", arrivo(i))
            end-if
            !Altrimenti consideriamo semplicemente controllato l'arrivo a questo item
            controllati(arrivo(i)) := 1

          end-if
        end-if
      end-do


      ! Ricerca locale qui
      forall (i in items)
        if (sel(i) = 0) then fine := false
        end-if

    end-do

    write("SOLUZIONE EURISTICO COSTRUTTIVO, con criterio pval")
    writeln("\tZEUR = ",zeur)
    ! forall(i, j in xeur)
    !   if(xeur(i, j) > eps) then
    !     write("x(", i,", ", j, " = 1")
    !   end-if


  end-procedure



  procedure BPPGP_Euristico_con_pval
    declarations
      disp: array(items) of integer ! item che possono essere inseriti
      sel: array(items) of integer ! item che sono già stati selezionati
      getdisp : boolean ! ho items da prendere
      controllati: array(items) of integer ! item già controllati in arrivo
      checking: integer !item in arrivo che sto controllando
      check_result: boolean !esito del checking -> true può diventare disponibile
      indice : integer
      fine : boolean !Booleano per controllare la fine del ciclo
      cap : integer

      pmax : integer !massima valore sull'arco della precedenza
      cmax : integer
    end-declarations

    zeur := 1 !Si parte per forza dal Bin 1
    fine := false
    forall(i in items) sel(i) := 0
    forall(i in items) disp(i) := 1

    forall(i in archi) disp(arrivo(i)) := 0
    forall(i in items) xeur(i):= 0

    cap := c
    while (not fine) do
      fine := true
      getdisp := false

      !Ciclo per controllare la disponibilità di item da selezionare
      forall (o in items) do
        if (disp(o) = 1) then
          write(o, " è disponibile -> ")
          getdisp := true
          break
        end-if
      end-do

      !Ciclo che viene percorso solamente in caso di non disponibilità: apre un nuovo bin se necessario
      while(not getdisp) do
        zeur += 1
        writeln("Costretto ad aprire ", zeur, " -> ")

        forall (i in items) controllati(i) := 0 !azzero gli item controllati
        forall(i in archi) do
          if (sel(arrivo(i)) <> 1) then
          !controllo solo gli item in arrivo che non ho già selezionati;va fatto prima del prossimo per poter azzerare sempre i controllati
            if (controllati(arrivo(i)) <> 1) then
              check_result := true !Inizialmente può essere inserito, se fallisce i controlli no
              checking := arrivo(i) !Sto controllanto l'item arrivo(i)

              !##### Ecco la ciccia: i controlli #####!
              forall(h in archi) do

                if (items(arrivo(h)) = checking) then
                  !quando nell'array arrivo trovo l'item che stiamo controllando ->
                  if (sel(partenza(h)) <> 1) then
                    ! Se la partenza non è stata selezionata -> il controllo fallisce
                    check_result := false
                    break
                  end-if
                  !Questo punto del codice viene raggiunto solamentese tutte gli item con precedenze sono stati già assegnati

                  forall(j in bins) do
                    !Facciamo ruotare la variabile j sui bin ->
                    if (xeur(partenza(h)) = j and zeur - pval(h) - j < 0) then
                      !Se ho assegnato l'item che sto controllando [partenza(h)] al bin numero [j],
                      !controllo che il numero del bin attuale [zeur] - il peso della precedenza [pval(h)] - il numero del bin dell'item con precedenza [j]
                      !sia maggiore o uguale a zero -> sia passato abbastanza tempo
                      !altrimenti il controllo fallisce
                      check_result := false
                      break

                    end-if
                  end-do
                  if(not check_result) then break
                  end-if
                end-if
              end-do

              if (check_result) then
              !Qui, se i controlli non sono falliti, aggiorniamo la disponibilità -> nel prossimo passaggio possiamo prendere quell'item che stava in arrivo
                disp (arrivo(i)) := 1
                getdisp := true
              !Altrimenti consideriamo semplicemente controllato l'arrivo a questo item
              controllati(arrivo(i)) := 1
              end-if
            end-if
          end-if
        end-do

      end-do



      ! Qui  selezioniamo un indice
      indice := 0 !lo dichiariamo a 0
      pmax := -1
      forall (i in items, j in archi ) do
        if  (disp(i) = 1 and sel(i) = 0 and partenza(j) = i) then
          ! if (partenza(j) = i) then
            ! Qui aggiorniamo l'indice selezionato considerando il suo pval
            if (pval(j) > pmax) then
              write ("indice = " ,i, ", pval = ", pval(j), " -> ")
              indice := i
              pmax := pval(j)
            end-if
          ! end-if
        end-if
      end-do

      write(" Scelgo ", indice," -> ")
      if (indice = 0) then
        write( "indice = 0 ->")
        cmax := 0
        forall (i in items) do
          if(disp(i) = 1 and sel(i) = 0 and pesi(i) > cmax and pesi(i) < cap) then
            indice := i
          end-if
        end-do
      end-if

      if(indice = 0) then
        while (true) do

        ! while (true) do ! trova un indice disponibile casualmente
          indice := ceil(random * n)

          if(disp(indice) = 1 and sel(indice) = 0) then
            write ("Seleziono ", indice, " -> ")
            break
          end-if
        end-do
      end-if

      if (pesi(indice) > cap) then
        zeur := zeur + 1
        cap := c - pesi(indice)
      else cap -= pesi(indice)
      end-if

      writeln("zeur = ", zeur," cap = ", cap, " ->" )

      disp(indice) := 0 !togliamo la disponibilità di indice
      sel(indice) := 1

      xeur(indice) := zeur

      !!!!!!!!!!!!AGGIORNAMENTO SEL!!!!!!!!!!

      !!ciclo di controllo precedenze!!
      forall (i in items) controllati(i) := 0 !azzero gli item controllati

      forall(i in archi) do
        if (sel(arrivo(i)) <> 1) then
        !controllo solo gli item in arrivo che non ho già selezionati;va fatto prima del prossimo per poter azzerare sempre i controllati
          if (controllati(arrivo(i)) <> 1) then
            check_result := true !Inizialmente può essere inserito, se fallisce i controlli no
            checking := arrivo(i) !Sto controllanto l'item arrivo(i)
            ! writeln("checnking: ", checking)

            !##### Ecco la ciccia: i controlli #####!
            forall(h in archi) do

              if (items(arrivo(h)) = checking) then
                !quando nell'array arrivo trovo l'item che stiamo controllando ->
                if (sel(partenza(h)) <> 1) then
                  ! Se la partenza non è stata selezionata -> il controllo fallisce
                  check_result := false
                  break
                end-if
                !Questo punto del codice viene raggiunto solamentese tutte gli item con precedenze sono stati già assegnati

                forall(j in bins) do
                  !Facciamo ruotare la variabile j sui bin ->
                  if (xeur(partenza(h)) = j and zeur - pval(h) - j < 0) then
                    !Se ho assegnato l'item che sto controllando [partenza(h)] al bin numero [j],
                    !controllo che il numero del bin attuale [zeur] - il peso della precedenza [pval(h)] - il numero del bin dell'item con precedenza [j]
                    !sia maggiore o uguale a zero -> sia passato abbastanza tempo
                    !altrimenti il controllo fallisce
                    check_result := false
                    break

                  end-if
                end-do

                if(not check_result) then break
                end-if
              end-if
            end-do

            if (check_result) then
            !Qui, se i controlli non sono falliti, aggiorniamo la disponibilità -> nel prossimo passaggio possiamo prendere quell'item che stava in arrivo
              disp (arrivo(i)) := 1
              ! writeln("diventa disponibile ", arrivo(i))
            end-if
            !Altrimenti consideriamo semplicemente controllato l'arrivo a questo item
            controllati(arrivo(i)) := 1

          end-if
        end-if
      end-do


      ! Ricerca locale qui
      forall (i in items)
        if (sel(i) = 0) then fine := false
        end-if

    end-do

    write("SOLUZIONE EURISTICO COSTRUTTIVO, con criterio pval")
    writeln("\tZEUR = ",zeur)
    ! forall(i, j in xeur)
    !   if(xeur(i, j) > eps) then
    !     write("x(", i,", ", j, " = 1")
    !   end-if


  end-procedure



  procedure BPPGP_Multistart
    declarations
      q: integer
    end-declarations
    zbest := zeur
    xbest := xeur

    forall (iterazione in 1..max_iter) do
      BPPGP_euristico
      if(zeur < zbest) then
        zbest:= zeur
        xbest := xeur
      end-if
    end-do
    writeln ("SOLUZIONE MULTISTART")
    writeln ("\tzbest = ", zbest)
  end-procedure




  procedure BPPGP_euristico
    declarations

      disp: array(items) of integer ! item che possono essere inseriti
      sel: array(items) of integer ! item che sono già stati selezionati
      getdisp : boolean ! ho items da prendere
      controllati: array(items) of integer ! item già controllati in arrivo
      checking: integer !item in arrivo che sto controllando
      check_result: boolean !esito del checking -> true può diventare disponibile
      indice : integer
      fine : boolean !Booleano per controllare la fine del ciclo
      cap : integer
    end-declarations

    zeur := 1 !Si parte per forza dal Bin 1
    fine := false
    !Non si può ciclare sulle strutture array, si deve ciclare sulle liste: quelli che vengono definiti da 1..n \ 1..m etc, come bins, items o archi
    forall(i in items) sel(i) := 0
    forall(i in items) disp(i) := 1
    forall(i in archi) disp(arrivo(i)) := 0
    forall(i in items) xeur(i):= 0

    cap := c
    while (not fine) do
      fine := true
      getdisp := false

      !Ciclo per controllare la disponibilità di item da selezionare
      forall (o in items) do
        if (disp(o) = 1) then
          write(o, " è disponibile -> ")
          getdisp := true
          break
        end-if
      end-do

      !Ciclo che viene percorso solamente in caso di non disponibilità: apre un nuovo bin se necessario
      while(not getdisp) do
        zeur += 1
        writeln("Costretto ad aprire ", zeur, " -> ")

        forall (i in items) controllati(i) := 0 !azzero gli item controllati
        forall(i in archi) do
          if (sel(arrivo(i)) <> 1) then
          !controllo solo gli item in arrivo che non ho già selezionati;va fatto prima del prossimo per poter azzerare sempre i controllati
            if (controllati(arrivo(i)) <> 1) then
              check_result := true !Inizialmente può essere inserito, se fallisce i controlli no
              checking := arrivo(i) !Sto controllanto l'item arrivo(i)

              !##### Ecco la ciccia: i controlli #####!
              forall(h in archi) do

                if (items(arrivo(h)) = checking) then
                  !quando nell'array arrivo trovo l'item che stiamo controllando ->
                  if (sel(partenza(h)) <> 1) then
                    ! Se la partenza non è stata selezionata -> il controllo fallisce
                    check_result := false
                    break
                  end-if
                  !Questo punto del codice viene raggiunto solamentese tutte gli item con precedenze sono stati già assegnati

                  forall(j in bins) do
                    !Facciamo ruotare la variabile j sui bin ->
                    if (xeur(partenza(h)) = j and zeur - pval(h) - j < 0) then
                      !Se ho assegnato l'item che sto controllando [partenza(h)] al bin numero [j],
                      !controllo che il numero del bin attuale [zeur] - il peso della precedenza [pval(h)] - il numero del bin dell'item con precedenza [j]
                      !sia maggiore o uguale a zero -> sia passato abbastanza tempo
                      !altrimenti il controllo fallisce
                      check_result := false
                      break

                    end-if
                  end-do
                  if(not check_result) then break
                  end-if
                end-if
              end-do

              if (check_result) then
              !Qui, se i controlli non sono falliti, aggiorniamo la disponibilità -> nel prossimo passaggio possiamo prendere quell'item che stava in arrivo
                disp (arrivo(i)) := 1
                getdisp := true
              !Altrimenti consideriamo semplicemente controllato l'arrivo a questo item
              controllati(arrivo(i)) := 1
              end-if
            end-if
          end-if
        end-do

      end-do




      while (true) do

      ! while (true) do ! trova un indice disponibile casualmente
        indice := ceil(random * n)

        if(disp(indice) = 1 and sel(indice) = 0) then
          write ("Seleziono ", indice, " -> ")
          break
        end-if
      end-do

      if (pesi(indice) > cap) then
        zeur := zeur + 1
        cap := c - pesi(indice)
      else cap -= pesi(indice)
      end-if
      writeln("Assegno a bin: ", zeur, " rimane cap: ", cap)


      ! if (zeur >= m) then
      !   writeln("tutti i bin sono occupati")
      !   break
      ! end-if
      disp(indice) := 0 !togliamo la disponibilità di indice
      sel(indice) := 1

      xeur(indice) := zeur

      ! forall (i in partenza) do
      !   if (partenza(i) = items(indice)) then
      !     forall (h in arrivo) do
      !       if (arrivo(i) = arrivo(h) and i <> h) then
      !         if(sel(partenza(h)) = 0) then

      !           break
      !         end-if
      !       end-if
      !     end-do

      !   end-if


      !!!!!!!!!!!!AGGIORNAMENTO SEL!!!!!!!!!!

      !!ciclo di controllo precedenze!!
      forall (i in items) controllati(i) := 0 !azzero gli item controllati

      forall(i in archi) do
        if (sel(arrivo(i)) <> 1) then
        !controllo solo gli item in arrivo che non ho già selezionati;va fatto prima del prossimo per poter azzerare sempre i controllati
          if (controllati(arrivo(i)) <> 1) then
            check_result := true !Inizialmente può essere inserito, se fallisce i controlli no
            checking := arrivo(i) !Sto controllanto l'item arrivo(i)
            ! writeln("checnking: ", checking)

            !##### Ecco la ciccia: i controlli #####!
            forall(h in archi) do

              if (items(arrivo(h)) = checking) then
                !quando nell'array arrivo trovo l'item che stiamo controllando ->
                if (sel(partenza(h)) <> 1) then
                  ! Se la partenza non è stata selezionata -> il controllo fallisce
                  check_result := false
                  break
                end-if
                !Questo punto del codice viene raggiunto solamentese tutte gli item con precedenze sono stati già assegnati

                forall(j in bins) do
                  !Facciamo ruotare la variabile j sui bin ->
                  if (xeur(partenza(h)) = j and zeur - pval(h) - j < 0) then
                    !Se ho assegnato l'item che sto controllando [partenza(h)] al bin numero [j],
                    !controllo che il numero del bin attuale [zeur] - il peso della precedenza [pval(h)] - il numero del bin dell'item con precedenza [j]
                    !sia maggiore o uguale a zero -> sia passato abbastanza tempo
                    !altrimenti il controllo fallisce
                    check_result := false
                    break

                  end-if
                end-do

                if(not check_result) then break
                end-if
              end-if
            end-do

            if (check_result) then
            !Qui, se i controlli non sono falliti, aggiorniamo la disponibilità -> nel prossimo passaggio possiamo prendere quell'item che stava in arrivo
              disp (arrivo(i)) := 1
              ! writeln("diventa disponibile ", arrivo(i))
            end-if
            !Altrimenti consideriamo semplicemente controllato l'arrivo a questo item
            controllati(arrivo(i)) := 1

          end-if
        end-if
      end-do


      ! Ricerca locale qui
      forall (i in items)
        if (sel(i) = 0) then fine := false
        end-if

    end-do

    ! write("SOLUZIONE EURISTICO COSTRUTTIVO")
    ! writeln("\tZEUR = ",zeur)
    ! forall(i, j in xeur)
    !   if(xeur(i, j) > eps) then
    !     write("x(", i,", ", j, " = 1")
    !   end-if


  end-procedure


  procedure modello_matematico
    ! declarations
    !   y: array(bins) of mpvar ! bins aperti
    !   x: array(bins, items) of mpvar !a che bin appartiene ogni item
    ! end-declarations
    z := sum(i in bins) y(i) ! (1) funzione obiettivo
    forall (j in items) sum(i in bins) x(i, j) = 1 ! (2) ogni item assegnato esattamente ad un bin
    forall (i in bins) sum (j in items) pesi(j) * x(i, j) <= c * y(i) ! (3) vincolo di capacità per bin aperto
    forall (u in archi) sum (i in bins) i * x (i, arrivo(u)) >= sum(i in bins) (i*x(i, partenza(u))) + pval(u) ! (4) vincolo sulle relazioni di precedenze

    forall (i in 1..(m-1)) y(i) >= y (i+1) ! (5) bin aperti in ordine
    forall (i in bins) y(i) is_binary ! (6)
    forall (i in bins, j in items) x(i, j) is_binary ! (7)
  end-procedure

  ! procedure Print_Status
  !   !restituisce lo stato del problema e quindi la natura della soluzione ottenuta
  !   case getprobstat of
  !     XPRS_OPT: solution_status:="Optimum found"
  !     XPRS_UNF: solution_status:="Unfinished"
  !     XPRS_INF: solution_status:="Infeasible"
  !     XPRS_UNB: solution_status:="Unbounded"
  !     XPRS_OTH: solution_status:="Failed"
  !     else solution_status:="???"
  !   end-case
  !   writeln("Problem status: ", solution_status)
  ! end-procedure

  procedure BPP_GP_output_MM
    writeln("SOLUZIONE")
    writeln("\tz = ", getobjval)
    forall(i in bins) do
      if (getsol(y(i)) > eps) then
        writeln("\ty(", i, ") = ",getsol(y(i)))
        forall(j in items)
          if (getsol(x(i,j)) > eps) then
            writeln("\t\tx(",i,", ", j, ") = ", getsol(x(i,j)))
          end-if
      end-if
    end-do
  end-procedure

end-model
