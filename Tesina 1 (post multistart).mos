model Progetto
  options noimplicit
  uses "mmxprs", "mmsystem", "mmsvg"
  forward procedure Print_Status
  forward procedure modello_matematico
  forward procedure BPP_GP_output_MM
  forward procedure BPPGP_euristico
  forward procedure BPPGP_Multistart
  forward procedure BPPGP_Euristico_con_pval
  forward procedure BPPGP_LS
  forward procedure BPPGP_GRASP
  forward procedure BPPGP_Rappresentazione_Grafica
  forward procedure BPPGP_euristico_n
  ! forward procedure pazzia
  declarations

    n: integer !numero di item, integer
    m: integer !numero di bin
    l: integer !numero di archi
    c : integer ! capacità dei bin

    ! inputfile = "BPP_progettoMOLP.dat" !nome del file
    inputfile = "Istanze/n=50/n=50(525).dat"

  end-declarations

  initialisations from inputfile
    n
    m
    l
    c
  end-initialisations

  declarations
    solution_status: string !stato del problema
    items = 1..n !range degli items
    bins = 1..m !range dei bins
    archi = 1..l ! range degli archi
    pesi : array(items) of integer ! array dei pesi
    z : linctr !funzione obiettivo
    !prec : array(items, items) of integer !matrice delle precedenze
    partenza : array(archi) of integer !item da cui parte l'arco della precedenza
    arrivo : array(archi) of integer !item a cui arriva l'arco della precedenza
    pval : array(archi) of integer !valore sull'arco della precedenza
    t1, t2, tempo : real
    eps= 0.0001
    max_iter : integer

    y: array(bins) of mpvar ! bins aperti
    x: array(bins, items) of mpvar !a che bin appartiene ogni item
    xeur: array(items) of integer
    zeur : integer
    xbest: array(items) of integer
    zbest: integer
    ndisp: integer
  end-declarations

  initialisations from inputfile
    arrivo
    partenza
    pesi
    pval
  end-initialisations

  !!!!!!MAIN!!!!!!!
  max_iter := 10000

  tempo := 0
  ! BPPGP_euristico
  BPPGP_euristico_n
  BPPGP_Multistart
  ! BPPGP_Euristico_con_pval
  ! BPPGP_LS
  ! BPPGP_GRASP
  modello_matematico
  ! pazzia


  ! Print_Status
  BPP_GP_output_MM
  ! BPPGP_Rappresentazione_Grafica
  !!!!!!!!!END MAIN !!!!!!!!!!
  procedure BPPGP_euristico
    declarations
      disp: array(items) of integer             ! item che possono essere inseriti
      sel: array(items) of integer              ! item che sono già stati selezionati
      getdisp : boolean                         ! vero se esistono item che sono disponibili
      controllati: array(items) of integer      ! item in arrivo che sono stati controllati
      check_result: boolean                     ! indica se un item diventa disponibile o no
      indice : integer                          ! variabile che ricorda, durante l'iterazione, l'item che sto selezionando
      fine : boolean                            ! assume valore false quando ho selezionato tutti gli item
      cap : integer                             ! capacità residua del bin corrente
    end-declarations
    t1 := gettime
    ! condizioni necessarie per iniziare l'euristico:
    fine := false
    forall(i in items) sel(i) := 0              ! Nessun item è inizialmente selezionato
    forall(i in items) disp(i) := 1             ! Tutti gli item sono disponibili ->
    forall(i in archi) disp(arrivo(i)) := 0     ! Pongo non disponibili gli item che sono arrivi di archi di precedenza
    forall(i in items) xeur(i):= 0              ! Assegno ad un ipotetico bin 0 tutti gli item nella soluzione euristica
    zeur := 1                                   ! Si parte per forza dal Bin 1
    cap := c                                    ! Il bin (1) aperto ha capacità corrente uguale alla capacità massima
    ! Iniziamo il ciclo esterno, ad ogni iterazione un item viene assegnato ad un bin
    while (not fine) do
      fine := true                              ! Evitiamo che ci si blocchi nel while (se non sono assegnati tutti gli item rimettiamo True -> più avanti)
      getdisp := false
      forall (o in items) do
        if (disp(o) = 1) then                   ! Se ho almeno un item disponibile per la selezione getdisp -> true
          ! write(o, " è disponibile -> ")
          getdisp := true                       ! ->
          break                                 ! Appena trovo un match interrompo il ciclo
        end-if
      end-do
      ! Ciclo che viene percorso solamente in caso di non disponibilità (getdisp = False) -> apre un nuovo bin.
      ! Posso avere problemi di disponibilità causati dal valore sugli archi delle precedenze (pval):
      ! Pur avendo già selezionato tutti gli item necessari, non sono ancora trascorsi sufficienti bin.
      while(not getdisp) do
        forall (i in items) controllati(i) := 0 ! Controllare se (come si spera) qualche item diventa disponibile con l'apertura di un nuovo bin
        zeur += 1                               ! Apro il nuovo Bin
        cap := c                                ! Aggiorno la capacità
        ! writeln("Costretto ad aprire ", zeur, " -> ")
        forall(i in archi) do                   ! Si cicla sugli archi perchè è necessario controllare gli arrivi (degli archi di precedenza)
          if (sel(arrivo(i)) <> 1 and controllati(arrivo(i)) <> 1) then
            ! Devo controllare solamente gli item che non ho precedentemente selezionato / controllato
            check_result := true                ! Inizialmente può essere inserito, se fallisce i controlli no
            forall(h in archi, j in bins) do
              ! Si cicla una seconda volta su archi perchè un item può essere arrivo di diversi archi, tutte le precedenze devono essere verificate
              ! perché l'arrivo diventi disponibile
              if (arrivo(h) = arrivo(i) and (sel(partenza(h)) <> 1 or (xeur(partenza(h)) = j and zeur - pval(h) - j < 0))) then
                ! 1) L'item "arrivo" nel ciclo interno deve coincidere con quello esterno (controllo tutti gli archi)
                ! 2) L'item "partenza" dell'arco è associato ad un bin j (quindi selezionato)
                ! 3) Devono essere passati sufficienti bin da soddisfare la precedenza
                check_result := false
                break
                ! Basta che una di queste condizione venga verificata e l'item non può diventare disponibile
              end-if
            end-do
            if (check_result) then              ! A seconda dell'esito del controllo inserisco tra i disponibili l'item "arrivo"
              disp (arrivo(i)) := 1
              getdisp := true
            end-if
            controllati(arrivo(i)) := 1         ! In ogni caso l'item "arrivo" è stato controllato
          end-if
        end-do
      end-do
      ! Selezioniamo casualmente un item tra quelli disponibili
      while (true) do
        indice := ceil(random * n)
        if(disp(indice) = 1 and sel(indice) = 0) then
          ! write ("Seleziono ", indice, " -> ")
          break
        end-if
      end-do
      ! Aggiornamento della capacità residua del bin
      if (pesi(indice) <= cap) then
        cap -= pesi(indice)
      else                                      ! Se il peso dell'item selezionato eccede la capacità residua del bin corrente
        zeur := zeur + 1                        ! Apro un nuovo bin e aggiorno la capacità
        cap := c - pesi(indice)
      end-if
      ! writeln("Assegno a bin: ", zeur, " (capacità residua: ", cap,")")
      sel(indice) := 1                          ! L'item estratto e assegnato diventa "selezionato"
      disp(indice) := 0                         ! Togliamo la disponibilità dall'item selezionato (non deve essere ri-estratto)
      xeur(indice) := zeur                      ! All'indice dell'item (nell'array della soluzione euristica) è assegnato il numero del bin (coppia item-bin)
      ! Si effettua l'aggiornamento degli item disponibili.
      ! Abbiamo un item in più nell'array selezionati e potenzialmente abbiamo aperto un bin
      forall (i in items) controllati(i) := 0
      forall(i in archi) do
        if (sel(arrivo(i)) <> 1 and controllati(arrivo(i)) <> 1) then
          check_result := true
          forall(h in archi, j in bins) do
            if (arrivo(h) = arrivo(i) and (sel(partenza(h)) <> 1 or (xeur(partenza(h)) = j and zeur - pval(h) - j < 0))) then
              check_result := false
              break
            end-if
          end-do
          if (check_result) then
            disp (arrivo(i)) := 1
          end-if
          controllati(arrivo(i)) := 1
        end-if
      end-do
      ! Se ho ancora degli item non selezionati, devo effettuare un altro ciclo
      forall (i in items)
        if (sel(i) = 0) then
          fine := false
          break
        end-if
    end-do
    t2 := gettime
    ! writeln("SOLUZIONE")
    ! writeln("tempo impiegato = ", t2 - t1)
    ! writeln("euristico costruttivo RANDOM")
    ! writeln("\tzeur = ",zeur)
  end-procedure
  
  procedure BPPGP_euristico_n
    declarations
      disp: array(items) of integer
      sel: array(items) of integer
      ! getdisp : boolean
      controllati: array(items) of integer
      nok : array(items) of integer
      check_result: boolean
      indice : integer
      fine : boolean
      cap : integer
      closest: integer
      ta: real
      hodisp : boolean
    end-declarations
    ! t1 := gettime
    fine := false
    forall(i in items) sel(i) := 0
    forall(i in items) disp(i) := 1
    hodisp := true
    forall(i in archi) disp(arrivo(i)) := 0
    forall(i in items) xeur(i):= 0
    zeur := 1
    cap := c
    while (not fine) do
      fine := true
      indice := ceil(random * n)
      closest := n+ 1
      forall (i in items) do
        if (disp(i) = 1 and sel(i) = 0 and indice - i < closest) then
          closest := indice - i
          indice := i
        end-if 
        if (disp(i) = 1 and indice - i >= closest) then
          break
        end-if
      end-do
      ! write ("sel ", indice, " -> ")
      if (pesi(indice) <= cap) then
        cap -= pesi(indice)
      else
        zeur := zeur + 1
        cap := c - pesi(indice)
      end-if
      ! writeln("[bin: ", zeur, " cap: ", cap,"]")
      sel(indice) := 1
      disp(indice) := 0
      xeur(indice) := zeur
      
      repeat
        if (not hodisp) then
          zeur += 1
          cap := c
            ! write("C_a_A ", zeur, " -> ")

        end-if
        
        forall (i in items) controllati(i) := 0
        forall(i in items) nok(i):= 0
        forall(i in archi) do                   
          if (sel(arrivo(i)) = 0 and sel(partenza(i)) = 1 and nok(arrivo(i)) = 0) then
            controllati(arrivo(i)) := 1
            forall (j in bins) do
              if (xeur(partenza(i)) = j and zeur - pval(i) - j < 0) then
                nok(arrivo(i)) := 1
                break
              elif (xeur(partenza(i)) < j) then
                break
              end-if
            end-do
          else
            nok(arrivo(i)) := 1
          end-if
        end-do
        
        hodisp := false
        forall (i in items) do
          if (controllati(i) = 1 and sel(i) = 0 and nok(i) = 0) then
            disp(i) := 1
          end-if
          if(sel(i) = 0) then
            fine := false
            if (disp(i) = 1 and pesi(i) < cap) then
              hodisp := true
            end-if
          end-if
        end-do
        
        if (fine) then
          hodisp := true
        end-if
      until hodisp or fine
      
      
      
      forall (i in items)
        if (sel(i) = 0) then
          fine := false
          break
        end-if
      
    end-do
    ! t2 := gettime
    ! writeln("##### COSTRUTTIVO OP #####")
    ! writeln("\tzeur = ",zeur)
    ! tempo := t2 - t1
    ! writeln("\ttempo impiegato = ", t2 - t1)
    ! forall (b in 1..(zeur+1)) do
    !   forall (i in items) do
    !     if (xeur(i) = b) then
    !       writeln("bin: ", b," item: ", i," (peso  = ", pesi(i),")")
    !     end-if
    !   end-do
    ! end-do
  end-procedure

  procedure BPPGP_GRASP
    declarations
      disp: array(items) of integer
      sel: array(items) of integer
      getdisp : boolean
      controllati: array(items) of integer
      check_result: boolean
      indice : integer
      fine : boolean
      cap : integer
      pvalmax : integer
      swap : integer
      clist : array(items) of integer !Candidate  List del GRASP
    end-declarations
    t1 := gettime
    zeur := 1
    fine := false
    ndisp := 0
    forall(i in items) sel(i) := 0
    forall(i in items) disp(i) := 1
    forall(i in archi) disp(arrivo(i)) := 0
    forall(i in items) xeur(i):= 0
    cap := c
    while (not fine) do
      fine := true
      ndisp := 0
      getdisp := false
      forall (o in items) do
        if (disp(o) = 1 and sel(o) <> 1) then
          getdisp := true
          ndisp += 1
        end-if
      end-do
      while(not getdisp) do
        forall (i in items) controllati(i) := 0
        zeur += 1
        cap := c
        writeln("Costretto ad aprire ", zeur, " -> ")
        forall(i in archi) do
          if (sel(arrivo(i)) <> 1 and controllati(arrivo(i)) <> 1) then
            check_result := true
            forall(h in archi, j in bins) do
              if (arrivo(h) = arrivo(i) and (sel(partenza(h)) <> 1 or (xeur(partenza(h)) = j and zeur - pval(h) - j < 0))) then
                check_result := false
                break
              end-if
            end-do
            if (check_result) then
              disp (arrivo(i)) := 1
              getdisp := true
              ndisp += 1
            end-if
            controllati(arrivo(i)) := 1
          end-if
        end-do
      end-do
      forall (i in items) clist(i) := 0
      pvalmax := 0
      !Si vuole individuare il valore massimo sugli archi di precedenza uscenti dagli item disponibili
      forall (i in items, j in archi) do
        ! aggiorniamo una variabile pvalmax che trovi il massimo dei pval
        if(pval(j) > pvalmax and disp(i) = 1 and sel(i) = 0 and partenza(j) = i) then
          ! 1) Il valore di pval dell'arco j deve essere maggiore rispetto a quello di pvalmax
          ! 2) L'item i deve essere disponibile
          ! 3) L'item i non deve essere selezionato
          ! 4) L'item i deve essere la partenza dell'arco j
          pvalmax := pval(i)
        end-if
      end-do
      ! Se (pvalmax - 2) è maggiore di 0 inseriamo nella candidate list tutti gli item (disponibili) da cui parte un arco con valore di
      ! precedenza maggiore a (pvalmax - 2)
      if ((pvalmax - 2) >= 0) then
        forall (i in items, j in archi) do
          if (pval(j) >= (pvalmax - 2) and disp(i) = 1 and sel(i) = 0 and partenza(j) = i) then
            clist(i) := 1
          end-if
        end-do
      else
      ! Se (pmax - 2) < 0 mettiamo tutti i disponibili nella candidate list
        forall(i in items) do
          if(disp(i) = 1) then
            clist(i) := 1
          end-if
        end-do
      end-if
      ! selezioniamo un item casuale presente nella candidate list
      while(true) do
        indice := ceil(random*n)
        if(clist(indice) = 1) then
          break
        end-if
      end-do
      write("Seleziono ", indice, " -> ")
      ! La restante parte del codice equivale all'euristico costruttivo RANDOM
      if (pesi(indice) <= cap) then
        cap -= pesi(indice)
      else
        zeur := zeur + 1
        cap := c - pesi(indice)
      end-if
      writeln("Assegno a bin: ", zeur, " (capacità residua: ", cap,")")
      ndisp -= 1
      sel(indice) := 1
      disp(indice) := 0
      xeur(indice) := zeur
      forall (i in items) controllati(i) := 0
      forall(i in archi) do
        if (sel(arrivo(i)) <> 1 and controllati(arrivo(i)) <> 1) then
          check_result := true
          forall(h in archi, j in bins) do
            if (arrivo(h) = arrivo(i) and (sel(partenza(h)) <> 1 or (xeur(partenza(h)) = j and zeur - pval(h) - j < 0))) then
              check_result := false
              break
            end-if
          end-do
          if (check_result) then
            disp (arrivo(i)) := 1
          end-if
          controllati(arrivo(i)) := 1
        end-if
      end-do
      forall (i in items)
        if (sel(i) = 0) then
          fine := false
          break
        end-if
    end-do
    t2 := gettime
    writeln("SOLUZIONE EURISTICO COSTRUTTIVO, con criterio GRASP")
    writeln ("tempo impiegato = ", t2 - t1)
    writeln("\tZEUR [GRASP] = ",zeur)
    ! forall(i in items) do
    !     writeln("\t(item ", i,", bin ",xeur(i),"); ")
    ! end-do
    ! writeln
  end-procedure

  procedure BPPGP_LS
    declarations
      disp: array(items) of integer
      sel: array(items) of integer
      getdisp : boolean
      controllati: array(items) of integer
      check_result: boolean
      indice : integer
      fine : boolean
      cap : integer
      pvalmax : integer
      pesomax : integer
      ndisp : integer                                       ! Numero di item a disponibili per la selezione
      swap : integer                                        ! Indice dell'item con cui sostituire il selezionato
    end-declarations
    t1 := gettime
    zeur := 1
    fine := false
    ndisp := 0
    forall(i in items) sel(i) := 0
    forall(i in items) disp(i) := 1
    forall(i in archi) disp(arrivo(i)) := 0
    forall(i in items) xeur(i):= 0
    cap := c
    while (not fine) do
      fine := true
      ndisp := 0
      getdisp := false
      forall (o in items) do
        if (disp(o) = 1 and sel(o) <> 1) then
          getdisp := true
          ndisp +=1                                         !Contiamo il numero di items disponibili
        end-if
      end-do
      while(not getdisp) do
        forall (i in items) controllati(i) := 0
        zeur += 1
        cap := c
        writeln("Costretto ad aprire ", zeur, " -> ")
        forall(i in archi) do
          if (sel(arrivo(i)) <> 1 and controllati(arrivo(i)) <> 1) then
            check_result := true
            forall(h in archi, j in bins) do
              if (arrivo(h) = arrivo(i) and (sel(partenza(h)) <> 1 or (xeur(partenza(h)) = j and zeur - pval(h) - j < 0))) then
                check_result := false
                break
              end-if
            end-do
            if (check_result) then
              disp (arrivo(i)) := 1
              getdisp := true
              ndisp += 1
            end-if
            controllati(arrivo(i)) := 1
          end-if
        end-do
      end-do
      indice := 0
      pvalmax := -1
      forall (i in items, j in archi ) do
        if (disp(i) = 1 and sel(i) = 0 and partenza(j) = i and pval(j) > pvalmax) then
          ! write ("indice = " ,i, ", pval = ", pval(j), " -> ")
          indice := i
          pvalmax := pval(j)
        end-if
      end-do
      if (indice <> 0) then
        write ("Seleziono ",indice," -> ")
      end-if
      if (indice = 0) then
        pesomax := 0
        forall (i in items) do
          if(disp(i) = 1 and sel(i) = 0 and pesi(i) > pesomax and pesi(i) < cap) then
            indice := i
            pesomax := pesi(i)
          end-if
        end-do
        if (indice <> 0) then
          write( "CR ", indice," -> ")
        end-if
      end-if
      if(indice = 0) then
        pesomax := 0
        forall (i in items) do
          if(disp(i) = 1 and sel(i) = 0 and pesi(i) > pesomax) then
            indice := i
            pesomax := pesi(i)
          end-if
        end-do
        write( "Peso -> ",indice," -> ")
      end-if
      ! Lo SWAP avviene dopo la selezione "con criterio" dell'item
      if(random < 0.5 and ndisp > 1) then                                 ! Lo SWAP avviene con una certa probabilità e solo se esistono altri item disponibili
        while (true) do
          swap := ceil(random * n)
          ! Il nuovo item viene selezionato random tra i disponibili e deve essere diverso da quello che era stato scelto
          if(disp(swap) = 1 and sel(swap) = 0 and swap <> indice) then
            indice := swap                                                ! Indice viene aggiornato
            write ("SWAP = ",indice , " -> ")
            break
          end-if
        end-do
      end-if
      ! La restante parte del codice equivale all'euristico costruttivo RANDOM
      if (pesi(indice) <= cap) then
        cap -= pesi(indice)
      else
        zeur := zeur + 1
        cap := c - pesi(indice)
      end-if
      writeln("Assegno a bin: ", zeur, " (capacità residua: ", cap,")")
      ndisp -= 1
      sel(indice) := 1
      disp(indice) := 0
      xeur(indice) := zeur
      forall (i in items) controllati(i) := 0
      forall(i in archi) do
        if (sel(arrivo(i)) <> 1 and controllati(arrivo(i)) <> 1) then
          check_result := true
          forall(h in archi, j in bins) do
            if (arrivo(h) = arrivo(i) and (sel(partenza(h)) <> 1 or (xeur(partenza(h)) = j and zeur - pval(h) - j < 0))) then
              check_result := false
              break
            end-if
          end-do
          if (check_result) then
            disp (arrivo(i)) := 1
          end-if
          controllati(arrivo(i)) := 1
        end-if
      end-do
      forall (i in items)
        if (sel(i) = 0) then
          fine := false
          break
        end-if
    end-do
    t2 := gettime
    writeln ("SOLUZIONE EURISTICO COSTRUTTIVO, con LOCAL SEARCH")
    writeln ("tempo impiegato = ", t2 - t1)
    writeln("\tZEUR = ", zeur)
  end-procedure

  procedure BPPGP_Euristico_con_pval
    declarations
      disp: array(items) of integer
      sel: array(items) of integer
      getdisp : boolean
      controllati: array(items) of integer
      check_result: boolean
      indice : integer
      fine : boolean
      cap : integer
      pvalmax : integer                                   ! Variabile per il confronto dei pval tra gli archi di precedenza
      pesomax : integer                                   ! Variabile per il confronto dei pesi tra gli item
    end-declarations
    t1 := gettime
    zeur := 1
    fine := false
    forall(i in items) sel(i) := 0
    forall(i in items) disp(i) := 1
    forall(i in archi) disp(arrivo(i)) := 0
    forall(i in items) xeur(i):= 0
    cap := c
    while (not fine) do
      fine := true
      getdisp := false
      forall (o in items) do
        if (disp(o) = 1) then
          write(o, " è disponibile -> ")
          getdisp := true
          break
        end-if
      end-do
      while(not getdisp) do
        forall (i in items) controllati(i) := 0
        zeur += 1
        cap := c
        writeln("Costretto ad aprire ", zeur, " -> ")
        forall(i in archi) do
          if (sel(arrivo(i)) <> 1 and controllati(arrivo(i)) <> 1) then
            check_result := true
            forall(h in archi, j in bins) do
              if (arrivo(h) = arrivo(i) and (sel(partenza(h)) <> 1 or (xeur(partenza(h)) = j and zeur - pval(h) - j < 0))) then
                check_result := false
                break
              end-if
            end-do
            if (check_result) then
              disp (arrivo(i)) := 1
              getdisp := true
            end-if
            controllati(arrivo(i)) := 1
          end-if
        end-do
      end-do
      ! Si seleziona un item secondo una specifiche serie di criteri
      indice := 0
      pvalmax := -1                                       ! Viene impostato a -1 perchè esistono anche precedenze con valore 0
      forall (i in items, j in archi ) do
        ! Attraverso questi confronti si seleziona l'item (disponibile) "partenza" associato all'arco con pval maggiore
        if (disp(i) = 1 and sel(i) = 0 and partenza(j) = i and pval(j) > pvalmax) then
          ! 1) L'item deve essere disponibile
          ! 2) L'item non deve essere già selezionato
          ! 3) L'item deve essere la "partenza" di un arco di precedenza
          ! 4) Il pval associato all'arco partente dall'item deve essere maggiore a pvalmax
          write ("indice = " ,i, ", pval = ", pval(j), " -> ")
          indice := i
          pvalmax := pval(j)                              ! Si aggiorna pvalmax quando viene superato da un nuovo item
        end-if
      end-do
      ! write(" Scelgo ", indice," -> ")
      ! Esistono situazioni in cui abbiamo item disponibili ma nessuno può essere scelto (ad esempio se nessuno è una partenza)
      ! In questi casi è previsto un secondo criterio: l'item il cui peso satura al massimo la capacità del bin corrente.
      if (indice = 0) then                                ! Indice vale 0 solo se non è stato selezionato nessun item
        write( "Valutiamo la capacità residua -> ")
        pesomax := 0
        forall (i in items) do
          ! Attraverso il confronto selezioniamo l'item che saturi al meglio il bin corrente
          if(disp(i) = 1 and sel(i) = 0 and pesi(i) > pesomax and pesi(i) < cap) then
            ! 1) L'item deve essere disponibile
            ! 2) L'item non deve essere già selezionato
            ! 3) L'item deve pesare più di pesomax
            ! 4) Il peso dell'item non deve eccedere la capacità del bin
            indice := i
            pesomax := pesi(i)
          end-if
        end-do
      end-if
      ! Se ancora una volta nessun item soddisfa le condizioni si passa a scegliere semplicemente quello dal peso maggiore
      if(indice = 0) then
        write( "Valutiamo il peso -> ")
        pesomax := 0
        forall (i in items) do
          ! Attraverso il confronto selezioniamo l'item con il peso maggiore
          if(disp(i) = 1 and sel(i) = 0 and pesi(i) > pesomax) then
            ! 1) L'item deve essere disponibile
            ! 2) L'item non deve essere già selezionato
            ! 3) L'item deve pesare più di pesomax
            indice := i
            pesomax := pesi(i)
          end-if
        end-do
      end-if
      ! La restante parte del codice equivale all'euristico costruttivo RANDOM
      if (pesi(indice) <= cap) then
        cap -= pesi(indice)
      else
        zeur := zeur + 1
        cap := c - pesi(indice)
      end-if
      writeln("Assegno a bin: ", zeur, " (capacità residua: ", cap,")")
      sel(indice) := 1
      disp(indice) := 0
      xeur(indice) := zeur
      forall (i in items) controllati(i) := 0
      forall(i in archi) do
        if (sel(arrivo(i)) <> 1 and controllati(arrivo(i)) <> 1) then
          check_result := true
          forall(h in archi, j in bins) do
            if (arrivo(h) = arrivo(i) and (sel(partenza(h)) <> 1 or (xeur(partenza(h)) = j and zeur - pval(h) - j < 0))) then
              check_result := false
              break
            end-if
          end-do
          if (check_result) then
            disp (arrivo(i)) := 1
          end-if
          controllati(arrivo(i)) := 1
        end-if
      end-do
      forall (i in items)
        if (sel(i) = 0) then
          fine := false
          break
        end-if
    end-do
    t2 := gettime
    writeln ("SOLUZIONE")
    writeln ("tempo impiegato = ", t2 - t1)
    writeln("euristico costruttivo con PVAL")
    writeln("\tzeur = ",zeur)
  end-procedure

  procedure BPPGP_Multistart
    t1 := gettime
    zbest := zeur
    xbest := xeur
    
    write("iterazione: 0 zeur = ", zeur," -> ")

    forall (iterazione in 1..max_iter) do
      BPPGP_euristico_n
      tempo += tempo
      if(zeur < zbest) then                     ! Se la soluzione dell'euristico è migliore dell'incumbet si aggiorna
        write("iterazione: ", iterazione," zeur = ", zeur," -> ")
        zbest := zeur
        xbest := xeur
      end-if
    end-do
    writeln("")
    t2 := gettime
    writeln ("SOLUZIONE MULTISTART")
    forall (b in 1..(zeur+1)) do
      forall (i in items) do
        if (xeur(i) = b) then
          writeln("bin: ", b," item: ", i," (peso  = ", pesi(i),")")
        end-if
      end-do
    end-do
    writeln ("tempo = ", t2-t1)
    writeln ("\tzbest = ", zbest)

    
  end-procedure

  procedure modello_matematico
    z := sum(i in bins) y(i)                                                                  ! (1) funzione obiettivo
    forall (j in items)
      sum(i in bins) x(i, j) = 1                                                              ! (2) ogni item assegnato esattamente ad un bin
    forall (i in bins)
      sum (j in items) pesi(j) * x(i, j) <= c * y(i)                                          ! (3) vincolo di capacità per bin aperto
    forall (u in archi)
      sum (i in bins) i * x (i, arrivo(u)) >= sum(i in bins) (i*x(i, partenza(u))) + pval(u)  ! (4) vincolo sulle relazioni di precedenze
    forall (i in 1..(m-1))
      y(i) >= y (i+1)                                                                         ! (5) bin aperti in ordine
    forall (i in bins)
      y(i) is_binary                                                                          ! (6)
    forall (i in bins, j in items)
      x(i, j) is_binary                                                                       ! (7)
    !Fine del modello matematico
    t1 := gettime
    minimize(z)
    t2 := gettime
  end-procedure

  procedure Print_Status
    !restituisce lo stato del problema e quindi la natura della soluzione ottenuta
    case getprobstat of
      XPRS_OPT: solution_status:="Optimum found"
      XPRS_UNF: solution_status:="Unfinished"
      XPRS_INF: solution_status:="Infeasible"
      XPRS_UNB: solution_status:="Unbounded"
      XPRS_OTH: solution_status:="Failed"
      else solution_status:="???"
    end-case
    writeln("Problem status: ", solution_status)
  end-procedure

  procedure BPP_GP_output_MM
    writeln("SOLUZIONE")
    ! writeln ("tempo impiegato = ",t2-t1)
    writeln("\tz = ", getobjval)
    ! forall(i in bins) do
    !   if (getsol(y(i)) > eps) then
    !     writeln("\ty(", i, ") = ",getsol(y(i)))
    !     forall(j in items)
    !       if (getsol(x(i,j)) > eps) then
    !         writeln("\t\tx(",i,", ", j, ") = ", getsol(x(i,j)))
    !       end-if
    !   end-if
    ! end-do
  end-procedure

  procedure BPPGP_Rappresentazione_Grafica
    declarations
      cont: integer
      larghezza : integer
    end-declarations

    larghezza := floor(c/zeur)
    svgaddgroup("b", "Bins", SVG_GRAY)
    svgsetstyle("b", SVG_STROKE, SVG_BLACK)
    svgsetstyle("b", SVG_STROKEWIDTH, 0.05)
    svgsetstyle("b", SVG_FILL, SVG_GRAY)

    svgaddgroup("i", "Items", SVG_LIME)
    svgsetstyle("i", SVG_STROKE, SVG_BLACK)
    svgsetstyle("i", SVG_STROKEWIDTH, 0.05)
    svgsetstyle("i", SVG_FILL, SVG_LIME)

    ! svgaddgroup("ti", SVG_RED)
    ! svgsetstyle("ti", SVG_FONTSIZE,"5px")

    svgsetgraphviewbox(0,0,zeur,c)
    svgsetgraphlabels("Bins", "Capacity")
    ! svgaddrectangle("b", 0, 0, 1, c)
    ! svgaddrectangle("i", 0, 0, 1, 150)
    ! cont := 150
    ! p := 200
    ! svgaddrectangle("i", 0, cont, 1, p)
    ! svgaddtext(0.25, cont + p/2, "io")
    write(larghezza)
    forall (b in 1..(zeur+1)) do
      cont := 0
      svgaddrectangle("b", (b-1), 0, 1, c)
      forall (i in items) do
        if (xeur(i) = b) then
          writeln("bin: ", b," item: ", i," (peso  = ", pesi(i),")")
          svgaddrectangle("i", (b-1), cont, 1, pesi(i))
          cont += pesi(i)
        end-if
      end-do
    end-do

    ! forall (i in 0..5)
    ! svgaddrectangle("b", i, 0, 1, 20)

    svgrefresh
    ! svgsave("graph502.svg")

    svgwaitclose
  end-procedure

  ! procedure pazzia
  !   declarations
  !     val : integer
  !     mprec: array(items, items) of integer               ! matrice di presenza delle precedenze
  !     mval: array(items, items) of integer                ! matrice di valori delle precdenze
  !     condizione: boolean
  !     succ: array (items) of integer                      ! Item che succedono l'item in iterazione
  !     cont : integer
  !     avanti : array(items) of integer
  !     nitems : integer

  !   end-declarations
  !   forall (i, h in items) mprec(i, h) := -1
  !   ! mprec è una matrice con valore 0 o 1, a seconda della presenza o meno della precedenza: se si leggono le righe, si ottengono tutti gli item che
  !   ! che seguono quello in considerazione, se si leggono le colonne, si ottengono tutti gli item che devono precedere quello in considerazione
  !   forall (i in items) do
  !   ! writeln("Analizzo ",i)
  !     forall (h in items) succ(h) := -1
  !     succ(i) := -5
  !     condizione := true
  !     cont := 1
  !     while(condizione) do
  !       condizione := false
  !       forall (j in archi) do
  !         if ((succ(partenza(j)) = (cont - 1)) or cont = -5) then
  !           condizione := true
  !           succ(arrivo(j)) := cont
  !         end-if
  !       end-do
  !       if (cont = -
  !       cont := cont + 1
  !     end-do
  !     forall (h in items) do
  !       if (succ(h) > 0 ) then
  !         mprec(i, h) := succ(h)
  !       end-if
  !     end-do
  !   end-do

  !   forall (i, h in items)
  !     if(mprec(i, h) > eps) then
  !       writeln (i," precede ",h, " di ", mprec(i, h))
  !     end-if

  !   forall(i in items) do
  !     nitems := -1
  !     forall (h in items) do
  !       if (mprec(i,h) > nitems) then
  !         nitems := mprec(i,h)
  !       end-if
  !     end-do
  !     writeln ("Massima precedenza di ",i," vale ", nitems
  !   end-do

  ! end-procedure
end-model
