model Progetto
  options noimplicit
  uses "mmxprs", "mmsystem"
  ! forward procedure Print_Status
  forward procedure modello_matematico
  forward procedure BPP_GP_output_MM
  forward procedure BPPGP_euristico

  declarations

    n: integer !numero di item, integer
    m: integer !numero di bin
    l: integer !numero di archi
    c : integer ! capacità dei bin

    inputfile = "BPP_progettoMOLP.dat" !nome del file

  end-declarations

  initialisations from inputfile
    n
    m
    l
    c
  end-initialisations

  declarations
    items = 1..n !range degli items
    bins = 1..m !range dei bins
    archi = 1..l ! range degli archi
    pesi : array(items) of integer ! array dei pesi
    z : linctr !funzione obiettivo
    !prec : array(items, items) of integer !matrice delle precedenze
    partenza : array(archi) of integer !item da cui parte l'arco della precedenza
    arrivo : array(archi) of integer !item a cui arriva l'arco della precedenza
    pval : array(archi) of integer !valore sull'arco della precedenza
    t1,t2 : real
    eps= 0.0001

    y: array(bins) of mpvar ! bins aperti
    x: array(bins, items) of mpvar !a che bin appartiene ogni item
  end-declarations

  initialisations from inputfile
    arrivo
    partenza
    pesi
    pval
  end-initialisations

  !!!!!!MAIN!!!!!!!

  ! write(arrivo)
  modello_matematico
  t1 := gettime
  minimize(z)
  t2 := gettime
  ! Print_Status
  BPP_GP_output_MM
  !!!!!!!!!END MAIN !!!!!!!!!!

  procedure BPPGP_euristico
    declarations
      xeur: array(items, bins) of integer
      yeur: array(bins) of integer
      disp: array(items) of integer ! item che possono essere inseriti
      sel: array(items) of integer ! item che sono già stati selezionati
      controllati: array(intems) of integer ! item già controllati in arrivo
      checking: integer !item in arrivo che sto controllando
      check_result: boolean !esito del checking -> true può diventare disponibile
      indice : integer
      fine : boolean
      cap : integer
      zeur : integer
    end-declarations

    zeur := 0
    forall(i in sel) sel(i) := 0
    forall(i in disp) disp(i) := 1
    forall(i in arrivo) disp(arrivo(i)):= 0

    cap := c
    while (not fine) do
      while (true) do ! trova un indice che sia disponibile casualmente
        indice:= ceil(random * n)
        if(disp(indice) = 1) then
          break
        end-if
      end-do

      if (pesi(indice) > cap) then
        zeur += 1
        cap := c - pesi(indice)
      else cap -= pesi(indice)
      end-if
        ! Attenzione, al numero del bin in relazione alle precedenze
      sel(indice) := 1
      xeur(indice,  zeur) := 1
      
      ! forall (i in partenza) do
      !   if (partenza(i) = items(indice)) then
      !     forall (h in arrivo) do
      !       if (arrivo(i) = arrivo(h) and i <> h) then
      !         if(sel(partenza(h)) = 0) then

      !           break
      !         end-if
      !       end-if
      !     end-do

      !   end-if
      end-do
      
      !!!!!!!!!!!!NICO!!!!!!!!!!
      !!ciclo di controllo precedenze!!
      forall (i in controllati) controllati(i) := 0 !azzero gli item controllati
      
      forall(i in arrivo) do
        if (sel(arrivo(i)) <> 1) then 
        !controllo solo gli item in arrivo che non ho già selezionati;va fatto prima del prossimo per poter azzerare sempre i controllati
          if (controllati(arrivo(i)) <> 1) then
            check_result := true !Inizialmente può essere inserito, se fallisce i controlli no
            checking := arrivo(i) !Sto controllanto l'item arrivo(i)
            
            !##### Ecco la ciccia: i controlli #####!
            forall(h in arrivo) do
            
              if (items(arrivo(h)) = checking) then
                !quando nell'array arrivo trovo l'item che stiamo controllando ->
                if (sel(partenza(h)) <> 1) then
                  ! Se la partenza non è stata selezionata -> il controllo fallisce
                  check_result := false
                  break
                end-if
                !Questo punto del codice viene raggiunto solamentese tutte gli item con precedenze sono stati già assegnati
                
                forall(b in bins) do
                  !Facciamo ruotare la variabile b sui bin ->
                  if (xeur(items(partenza(h)), b) = 1 and zeur - pval(h) - b < 0) then
                    !Se ho assegnato l'item che sto controllando [partenza(h)] al bin numero [b], 
                    !controllo che il numero del bin attuale [zeur] - il peso della precedenza [pval(h)] - il numero del bin dell'item con precedenza [b]
                    !sia maggiore o uguale a zero -> sia passato abbastanza tempo
                    !altrimenti il controllo fallisce
                    check_result := false
                    break
                  end-if
                end-do
              end-if
            end-do
            
            if (check_result) then
            !Qui, se i controlli non sono falliti, aggiorniamo la disponibilità -> nel prossimo passaggio possiamo prendere quell'item che stava in arrivo 
              disp (arrivo(i)) := 1
            else  
            !Altrimenti consideriamo semplicemente controllato l'arrivo a questo item
              controllati(arrivo(i)) := 1
            end-if
              
          end-if
        end-if
      end-do
      
      
    


  end-procedure
  
  
  procedure modello_matematico
    ! declarations
    !   y: array(bins) of mpvar ! bins aperti
    !   x: array(bins, items) of mpvar !a che bin appartiene ogni item
    ! end-declarations
    z := sum(i in bins) y(i) ! (1) funzione obiettivo
    forall (j in items) sum(i in bins) x(i, j) = 1 ! (2) ogni item assegnato esattamente ad un bin
    forall (i in bins) sum (j in items) pesi(j) * x(i, j) <= c * y(i) ! (3) vincolo di capacità per bin aperto
    forall (u in archi) sum (i in bins) i * x (i, arrivo(u)) >= sum(i in bins) (i*x(i, partenza(u))) + pval(u) ! (4) vincolo sulle relazioni di precedenze

    forall (i in 1..(m-1)) y(i) >= y (i+1) ! (5) bin aperti in ordine
    forall (i in bins) y(i) is_binary ! (6)
    forall (i in bins, j in items) x(i, j) is_binary ! (7)
  end-procedure

  ! procedure Print_Status
  !   !restituisce lo stato del problema e quindi la natura della soluzione ottenuta
  !   case getprobstat of
  !     XPRS_OPT: solution_status:="Optimum found"
  !     XPRS_UNF: solution_status:="Unfinished"
  !     XPRS_INF: solution_status:="Infeasible"
  !     XPRS_UNB: solution_status:="Unbounded"
  !     XPRS_OTH: solution_status:="Failed"
  !     else solution_status:="???"
  !   end-case
  !   writeln("Problem status: ", solution_status)
  ! end-procedure

  procedure BPP_GP_output_MM
    writeln("SOLUZIONE")
    writeln("\tz = ", getobjval)
    forall(i in bins) do
      if (getsol(y(i)) > eps) then
        writeln("\ty(", i, ") = ",getsol(y(i)))
        forall(j in items)
          if (getsol(x(i,j)) > eps) then
            writeln("\t\tx(",i,", ", j, ") = ", getsol(x(i,j)))
          end-if
      end-if
    end-do
  end-procedure

end-model
